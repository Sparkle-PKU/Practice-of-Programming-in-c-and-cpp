'''有一种简单的加密算法，对于一个长度为n的字符串，这个算法将会以第(n+1)/2（向下取整）个字符为中间轴(最左边的字符算第1个字符），将该字符写在密文的开头，然后对左半部分按照同样的办法进行加密并写下密文，再对右半部分按照同样的办法进行加密并写下密文。以此类推，直到左右部分为空，即完成加密。

例如，如果要对12345678进行加密，第一步将选择4作为中间轴，将其写在密文开头，然后继续对左右两边（123和5678）分别继续按这个算法处理并写下，我们可以将其记作4[123][5678]（[]代表待加密处理的部分）。

对于左半部分123，中间轴是2，左半部分为1，右半部分为3因此加密结果为213（1的中间轴为1，左右均为空，因此结果为1，而3同理）。

对于右半部分5678，中间轴是6，左半部分为5，右半部分为78，因此加密结果为65[78] → 6578（78的中间轴为7，左半部分为空，右半部分为8，因此得到78）。

简单来说，整个加密过程如下：

12345678 → 4[123][5678] → 42[1][3][5678]→ 4213[5678] → 42136[5][78] → 42136578

因此，对12345678的加密结果为42136578。

现在给出一个长度为n(1 ≤ n ≤  50000)的由数字构成的字符串，这个字符串是加密后的密文，请你还原出加密前的明文。
输入
一行，一个长度为n(1 ≤ n ≤ 50000)的由数字构成的字符串字符串，代表加密后的密文。
输出
一行，一个长度同样为n的字符串，代表解密后的明文。'''
i=0
def dfs(s,l,r,res):
    global i
    if l>r:
        return
    m=(l+r)//2
    res[m]=s[i]
    i+=1
    dfs(s,l,m-1,res)
    dfs(s,m+1,r,res)

s=input()
res=[0]*(len(s))
dfs(s,0,len(s)-1,res)
print("".join(map(str,res)))